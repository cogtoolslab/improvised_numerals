---
title: "1st Year Paper Stats for Iterated Number"
author: Sebastian Holt
output: html_notebook
---

```{r libraries, echo=FALSE}

library(lme4) # need for running lmer
library(tidyverse)
library(coda)
require(languageR)
library(lmerTest) #need this for lmer p values!!! Maybe it's not so important...
library(emmeans)
library(data.table)


```

```{r get_data, echo=FALSE}
# import the data that was output from internum_analysis.ipynb
# dat1 = read_csv("../results/csv/iterated_number_group_data_run1.csv")
# dat2 = read_csv("../results/csv/iterated_number_group_data_run2.csv")
# dat3 = read_csv("../results/csv/iterated_number_group_data_run3.csv")
# dat4 = read_csv("../results/csv/iterated_number_group_data_run4.csv")
# dat5 = read_csv("../results/csv/iterated_number_group_data_run5.csv")
dat6 = read_csv("../results/csv/iterated_number_group_data_run6.csv")
# dat = rbind(dat2, dat3, dat4, dat5, dat6)
# games = unique(dat$gameID)

dud_games = c(#"6769-3ee1e797-2c5b-4441-8d67-5ccd1c6b9a73",    #number
             "8369-76e6f73d-922a-4aca-b98a-8c96026aa48a",    #number
             "1372-60cdfd55-28bb-411c-b777-c51eaadee7a9",    #shape
             "2949-1e579088-8493-4c07-873c-7bd6d00685e3",    #shape
             "7197-6d1f3fda-040a-455c-aef0-279ba9aef053",    #shape
             "9237-4cc76e85-9955-4cef-b03c-5c68f46321ca",    #shape
             "1947-29382ba4-5747-456d-ba8b-276812fc1fb3")    #shape
bad_games <- dat6[ dat6$gameID %in% dud_games, ]
dat <- dat6[ ! dat6$gameID %in% dud_games, ]
dat$block <- floor((dat$trialNum - 1) / 8) + 1 # get block number from trial number

dat_num = filter(dat,Game_Condition == 'number')
dat_aml = filter(dat,Game_Condition == 'shape')

```

Before beginning any analyses, just some summary statistics:
```{r accuracy_ttest}

# get accuracy data by game for all games
acc <- dat %>% group_by(Game_Condition, gameID) %>%
  count(outcome) %>% filter(outcome == TRUE)
  
# count up the accuracy by game in each condition, then store all in one dataframe
number_acc <- data.frame((acc %>% filter(Game_Condition == 'number'))$n)
shape_acc <- data.frame((acc %>% filter(Game_Condition == 'shape'))$n)
number_acc$cond <- 'number'
shape_acc$cond <- 'shape'
colnames(number_acc) <- c("N","cond")
colnames(shape_acc) <- c("N","cond")
all_accs <- rbind.data.frame(number_acc, shape_acc)

# now do the t-test comparing accuracy in each condition
acc_ttest <- t.test((acc %>% filter(Game_Condition == 'number'))$n,
                    (acc %>% filter(Game_Condition == 'shape'))$n)

# and plot the two distributions
ggplot(all_accs, aes(N, fill = cond)) + geom_density(alpha = 0.2)

```

Now look at average stroke count by condition and see if they differ:
```{r strokecount_ttest}
dat$numStrokes <- dat$numStrokes %>% as.numeric()

typeof(dat$numStrokes)
strokes <- dat %>% group_by(Game_Condition, gameID) %>% 
  summarise_at(vars(numStrokes), funs(mean(., na.rm=TRUE)))

aggregate(dat[, numStrokes], list(dat$Game_Condition), mean)
  
t.test((acc %>% filter(Game_Condition == 'number'))$n,
       (acc %>% filter(Game_Condition == 'shape'))$n)

```


First going to look for main effects of each important IV (number and animal) on each of our four DVs from the pre-reg
```{r num_main}
ik_num <- lm(data=dat, meanPixelIntensity ~ cardinality)
st_num <- lm(data=dat, numStrokes ~ cardinality) # significant of course
dr_num <- lm(data=dat, drawDuration ~ cardinality)
ac_num <- lm(data=dat, outcome ~ cardinality, family = 'binomial')
ik_num_stats <- c(round(anova(ik_num)[1,4],3), round(anova(ik_num)[1,5],3))
st_num_stats <- c(round(anova(st_num)[1,4],3), round(anova(st_num)[1,5],3))
dr_num_stats <- c(round(anova(dr_num)[1,4],3), round(anova(dr_num)[1,5],3))
ac_num_stats <- c(round(anova(ac_num)[1,4],3), round(anova(ac_num)[1,5],3))
```


```{r aml_main}
ik_aml <- lm(data=dat, meanPixelIntensity ~ category)
st_aml <- lm(data=dat, numStrokes ~ category)
dr_aml <- lm(data=dat, drawDuration ~ category)
ac_aml <- lm(data=dat, outcome ~ category, family = 'binomial')
ik_aml_stats <- c(round(anova(ik_aml)[1,4],3), round(anova(ik_aml)[1,5],3))
st_aml_stats <- c(round(anova(st_aml)[1,4],3), round(anova(st_aml)[1,5],3))
dr_aml_stats <- c(round(anova(dr_aml)[1,4],3), round(anova(dr_aml)[1,5],3))
ac_aml_stats <- c(round(anova(ac_aml)[1,4],3), round(anova(ac_aml)[1,5],3))

# show it in a pretty way; figure out by and by, not sure what's the norm
# library(knitr)
# kable(c(as.character(ik_aml_stats),as.character(st_aml_stats)))
```
```{r interactions}
# looking to see what is the interaction of game condition with out main IVs not already explained by that IV
ik_CrdCnd <- lm(data=dat, meanPixelIntensity ~ cardinality*Game_Condition)
ik_CatCnd <- lm(data=dat, meanPixelIntensity ~ category*Game_Condition)
st_CrdCnd <- lm(data=dat, numStrokes ~ cardinality*Game_Condition)
st_CatCnd <- lm(data=dat, numStrokes ~ category*Game_Condition)
dr_CrdCnd <- lm(data=dat, drawDuration ~ cardinality*Game_Condition)
dr_CatCnd <- lm(data=dat, drawDuration ~ category*Game_Condition)
ac_CrdCnd <- lm(data=dat, outcome ~ cardinality*Game_Condition, family = 'binomial')
ac_CatCnd <- lm(data=dat, outcome ~ category*Game_Condition, family = 'binomial')
ik_CrdCnd_stats <- c(round(anova(ik_CrdCnd)[3,4],3), round(anova(ik_CrdCnd)[3,5],3))
ik_CatCnd_stats <- c(round(anova(ik_CatCnd)[3,4],3), round(anova(ik_CatCnd)[3,5],3))
st_CrdCnd_stats <- c(round(anova(st_CrdCnd)[3,4],3), round(anova(st_CrdCnd)[3,5],3))
st_CatCnd_stats <- c(round(anova(st_CatCnd)[3,4],3), round(anova(st_CatCnd)[3,5],3))
dr_CrdCnd_stats <- c(round(anova(dr_CrdCnd)[3,4],3), round(anova(dr_CrdCnd)[3,5],3))
dr_CatCnd_stats <- c(round(anova(dr_CatCnd)[3,4],3), round(anova(dr_CatCnd)[3,5],3))
ac_CrdCnd_stats <- c(round(anova(ac_CrdCnd)[3,4],3), round(anova(ac_CrdCnd)[3,5],3))
ac_CatCnd_stats <- c(round(anova(ac_CatCnd)[3,4],3), round(anova(ac_CatCnd)[3,5],3))

```


### predicting strokes from cardinality, category, and condition
```{r}
model.strokes <- lmer(data = dat,
                 numStrokes ~ cardinality * Game_Condition 
                 + (1 | gameID))
summary(model.strokes)

```


### several other maximal models
```{r maximal_models}
# for each DV (total ink, number of strokes, and draw duration) store the lmer
lmer_ink <- lmer(data = dat,
                 meanPixelIntensity ~ cardinality * category * Game_Condition * block
                 + (1 + cardinality * category | gameID))

lmer_str <- lmer(data = dat,
                 numStrokes ~ cardinality * category * Game_Condition * block
                 + (1 + cardinality * category | gameID))

lmer_dur <- lmer(data = dat,
                 drawDuration ~ cardinality * category * Game_Condition * block
                 + (1 + cardinality * category | gameID))

glmer_ac <- glmer(data=dat,
                  outcome ~ cardinality * category * Game_Condition * block
                  + (1 + cardinality * category | gameID),
                  family = 'binomial')
```
### These appear to not converge. So let's simplify the models
```{r reduced_models_comparisons}
# a set of models removing the category (animal) information from random effects
lmer_ink_car <- lmer(data = dat,
                 meanPixelIntensity ~ cardinality * category * Game_Condition * block
                 + (1 + cardinality | gameID))

lmer_str_car <- lmer(data = dat,
                 numStrokes ~ cardinality * category * Game_Condition * block
                 + (1 + cardinality | gameID))

lmer_dur_car <- lmer(data = dat,
                 drawDuration ~ cardinality * category * Game_Condition * block
                 + (1 + cardinality | gameID))

glmer_ac_car <- glmer(data=dat,
                  outcome ~ cardinality * category * Game_Condition * block
                  + (1 + cardinality | gameID),
                  family = 'binomial')

# a set of models removing the cardinality information from random effects
lmer_ink_cat <- lmer(data = dat,
                 meanPixelIntensity ~ cardinality * category * Game_Condition * block
                 + (1 + category | gameID))

lmer_str_cat <- lmer(data = dat,
                 numStrokes ~ cardinality * category * Game_Condition * block
                 + (1 + category | gameID))

lmer_dur_cat <- lmer(data = dat,
                 drawDuration ~ cardinality * category * Game_Condition * block
                 + (1 + category | gameID))

glmer_ac_cat <- glmer(data=dat,
                  outcome ~ cardinality * category * Game_Condition * block
                  + (1 + category | gameID),
                  family = 'binomial')


# a set of models removing the any slope in the random effects
lmer_ink_flat <- lmer(data = dat,
                 meanPixelIntensity ~ cardinality * category * Game_Condition * block
                 + (1 | gameID))

lmer_str_flat <- lmer(data = dat,
                 numStrokes ~ cardinality * category * Game_Condition * block
                 + (1 | gameID))

lmer_dur_flat <- lmer(data = dat,
                 drawDuration ~ cardinality * category * Game_Condition * block
                 + (1 | gameID))

glmer_ac_flat <- glmer(data=dat,
                  outcome ~ cardinality * category * Game_Condition * block
                  + (1 | gameID),
                  family = 'binomial')

glm_ac_fixed <- glm(data=dat,
                  outcome ~ cardinality * Game_Condition * block, # * category
                  family = 'binomial') # this actually performs better when you take out 'category'

glmer_ac_small <- glmer(data=dat,
                  outcome ~ Game_Condition * block
                  + (1 | gameID),
                  family = 'binomial')
BIC(glm_ac_flat)
BIC(glm_ac_fixed)
BIC(glmer_ac_small)

```
``` {r annotated BIC comparisons}

# predicting meanPixelIntensity, using...
# Full model with cardinality in random effects:
# cardinality * category * Game_Condition * block + (1 + cardinality | gameID))    # BIC -9781.206
# Remove all the interaction terms:
# cardinality + category + Game_Condition + block + (1 + cardinality | gameID))    # BIC -10215.27  # winner?
# Remove block:
# cardinality + category + Game_Condition + (1 + cardinality | gameID))            # BIC -10214.78
# Remove game condition as well:
# cardinality + category + (1 + cardinality | gameID))                             # BIC -10184.58
# Reintroduce the interaction between number & shape?
# cardinality * category + (1 + cardinality | gameID))                             # BIC -10120.29
# Include interaction between cardinality and/or category and game condition:
# cardinality + category * Game_Condition + block + (1 + cardinality | gameID))    # BIC -10165.93
# cardinality + category + Game_Condition + cardinality:Game_Condition + block + (1 + cardinality | gameID))    # BIC -10203.72  # winner!
# cardinality + category * Game_Condition + cardinality:Game_Condition + block + (1 + cardinality | gameID))    # BIC -10154.39
ink_model <- lmer(data = dat, meanPixelIntensity ~ 
               cardinality + category + Game_Condition + block + (1 + cardinality | gameID))
summary(ink_model)

test1 <- lmer(data = dat, meanPixelIntensity ~ 
               category + Game_Condition + block + (1 + cardinality | gameID))

anova(ink_model,test1)
# predicting numStrokes, using...
# Full model with cardinality in random effects:
# cardinality * category * Game_Condition * block + (1 + cardinality | gameID))    # BIC 9605.77
# Remove all interaction terms:
# cardinality + category + Game_Condition + block + (1 + cardinality | gameID))    # BIC 9587.28  # winner?
# Remove block:
# cardinality + category + Game_Condition + (1 + cardinality | gameID))            # BIC 9686.597
# Remove game condition as well:
# cardinality + category + (1 + cardinality | gameID))                             # BIC 9702.524
# Reintroduce the interaction between number & shape?
# cardinality * category + (1 + cardinality | gameID))                             # BIC 9735.728
# Reintroduce that interaction into the currently winning model:
# cardinality * category + Game_Condition + block + (1 + cardinality | gameID))    # BIC 9620.815
# Include interaction between cardinality and/or category and game condition:
# cardinality + category * Game_Condition + block + (1 + cardinality | gameID))    # BIC 9496.323 # didn't converge
# cardinality + category + Game_Condition + cardinality:Game_Condition + block + (1 + cardinality | gameID))    # BIC 9555.483
# cardinality + category * Game_Condition + cardinality:Game_Condition + block + (1 + cardinality | gameID))    # BIC 9464.525 # winner!
str_model <- lmer(data = dat, numStrokes ~
               cardinality + category * Game_Condition + cardinality:Game_Condition + block + (1 + cardinality | gameID))

# how does the model fare when you take out each relevant predictor? This will tell us how much variability in animals is predictive of str, rather than a different esimate for each particular animal
str_no_cat <- lmer(data = dat, numStrokes ~
               cardinality * Game_Condition + block + (1 + cardinality | gameID))
str_no_car <- lmer(data = dat, numStrokes ~
               category * Game_Condition + block + (1 + cardinality | gameID))

anova(str_model,str_no_cat)
anova(str_model,str_no_car)
BIC(str_model)
summary(str_model)
# predicting drawDuration, using...
# Full model with cardinality in random effects:
# cardinality * category * Game_Condition * block + (1 + cardinality | gameID))    # BIC 10236.73
# Remove all interaction terms:
# cardinality + category + Game_Condition + block + (1 + cardinality | gameID))    # BIC 10162.24  # winner?
# Remove block:
# cardinality + category + Game_Condition + (1 + cardinality | gameID))            # BIC 10617.5
# Remove game condition as well:
# cardinality + category + (1 + cardinality | gameID))                             # BIC 10627.63
# Reintroduce the interaction between number & shape?
# cardinality * category + (1 + cardinality | gameID))                             # BIC 10658.04
# Reintroduce that interaction into the currently winning model:
# cardinality * category + Game_Condition + block + (1 + cardinality | gameID))    # BIC 10194.77
# Include interaction between cardinality and/or category and game condition:
# cardinality + category * Game_Condition + block + (1 + cardinality | gameID))    # BIC 10179.82
# cardinality + category + Game_Condition + cardinality:Game_Condition + block + (1 + cardinality | gameID))    # BIC 10125.5  # winner!
# cardinality + category * Game_Condition + cardinality:Game_Condition + block + (1 + cardinality | gameID))    # BIC 10143.08
dur_model <- lmer(data = dat, drawDuration ~
               cardinality + category + Game_Condition + cardinality:Game_Condition + block + (1 + cardinality | gameID))
summary(dur_model)
# predicting outcome, using...
# Model with only intercept in random effects :
# cardinality * category * Game_Condition * block + (1 | gameID)            # BIC 1129.357  # doesn't converge
# Model with only intercept in random effects and no interactions:
# cardinality + category + Game_Condition + block + (1 | gameID)            # BIC 1003.702  # winner?
# Remove Game_Condition & block:
# cardinality + category + (1 | gameID)                                     # BIC 1024.696
# Reintroduce the interaction term between them:
# cardinality * category + (1 | gameID)                                     # BIC 1044.447  # also doesn't converge
# Remove the random effect entirely and add back in all fixed effects:
# cardinality + category + Game_Condition + block                           # BIC 1074.597
# Include the interactions in these terms:
# cardinality * category * Game_Condition * block                           # BIC 1205.45
# Include interaction between cardinality and/or category and game condition:
# cardinality + category * Game_Condition + block + (1 | gameID)           # BIC 1023.897
# cardinality + category + Game_Condition + cardinality:Game_Condition + block + (1 | gameID)    # BIC 998.1115  # didn't converge
# cardinality + category * Game_Condition + cardinality:Game_Condition + block + (1 | gameID)    # BIC 1018.259 # didn't converge

acc_model <- glmer(data=dat, outcome ~
                     cardinality + category + Game_Condition + block + (1 | gameID),
                   family = 'binomial')
acc_no_cat <- glmer(data=dat, outcome ~
                     cardinality + Game_Condition + block + (1 | gameID),
                   family = 'binomial')
acc_no_car <- glmer(data=dat, outcome ~
                     category + Game_Condition + block + (1 | gameID),
                   family = 'binomial')

anova(acc_model,acc_no_cat)
anova(acc_model,acc_no_car)

BIC(acc_model)
summary(acc_model)
```


``` {r models we settled on as the best for each DV}
summary(ink_model)
anova(ink_model)
summary(str_model)
summary(dur_model)
summary(acc_model)

```

```{r CLF_probabilities}
clf_dat = read_csv("../results/csv/CLF_targ_probs.csv")
clf_6 = clf_dat %>% filter(layer==6)
setnames(clf_6, "prob", "logprob")

test1 <- lm(data=clf_6, logprob ~ condition*clf) #  +  (1 | sketch_id)
summary(test1)

# https://vasishth-statistics.blogspot.com/2018/04/a-little-known-fact-paired-t-test-is.html
test2 <- lmer(data=clf_6, logprob ~ condition  +  (1 | sketch_id))
summary(test2)

ggplot(clf_6, aes(logprob, fill = condition)) + geom_density(alpha = 0.2)
```

